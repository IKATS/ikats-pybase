"""
Copyright 2018-2019 CS SystÃ¨mes d'Information

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

"""
import json
import logging

from apps.algo.catalogue.models.business.factory import FactoryCatalogue
from apps.algo.catalogue.models.business.implem import Implementation
from apps.algo.catalogue.models.business.profile import ProfileItem, Argument
from apps.algo.custom.models.business.algo import CustomizedAlgo
from ikats.core.library.exception import IkatsException

LOGGER = logging.getLogger("CheckEngine")


class CheckItem(object):
    """
    Checker of the inputs and parameters of an operator
    """

    def __init__(self, check_type, check_target, checked_value, msg):
        self._json_obj = {'check_rule': check_type,
                          'target': self.get_target_info(check_target),
                          'checked_content': checked_value,
                          'msg': msg}

    def to_json_obj(self):
        """
        Gets the JSON object of the item to check
        :return:
        """
        return self._json_obj

    @classmethod
    def get_target_info(cls, check_target):
        """
        Gets the type of the object to check
        :param check_target:
        :return:
        """
        if isinstance(check_target, ProfileItem):
            return "{} {}".format(type(check_target).__name__, check_target.name)
        else:
            return "{}".format(check_target)


class CheckStatus(object):
    """
    Element of checking information about one submitted parameter value for resource CustomizedAlgo.
    CheckStatus are generated by the CheckEngine.

    """

    def __init__(self, checked_resource, checked_resource_location=None):
        self._error_list = []
        self._checked_resource = checked_resource
        self._checked_resource_location = checked_resource_location

    def add_error(self, check_type, check_target, checked_value, msg):
        """
        Add a new error in the status
        :param check_type:
        :param check_target:
        :param checked_value:
        :param msg:
        :return:
        """
        if isinstance(check_target, Argument):
            # !!! do not append the real value here: might be very big !!!
            self._error_list.append(CheckItem(check_type, check_target, checked_value="...", msg=msg))
        else:
            self._error_list.append(CheckItem(check_type, check_target, checked_value=checked_value, msg=msg))

    def has_errors(self):
        """
        Indicates if at least one error is present
        :return:
        """
        return len(self._error_list) > 0

    def set_checked_resource_location(self, location):
        """
        Setter for the _checked_resource_location
        :param location:
        :return:
        """
        self._checked_resource_location = location

    def to_dict(self, data_info=None):
        """
        Return a dict corresponding to the status of the checked object
        :param data_info:
        :return:
        """
        my_dict = {'checked_resource_type': type(self._checked_resource).__name__, }

        if self._checked_resource.db_id is not None:
            my_dict['checked_resource_id'] = self._checked_resource.db_id

        if self._checked_resource_location is not None:
            my_dict['checked_resource_location'] = self._checked_resource_location

        my_dict['checked_resource_name'] = self._checked_resource.name

        if data_info is not None:
            my_dict['checked_data_info'] = data_info

        my_encoded_errors = []

        for item in self._error_list:
            my_encoded_errors.append(item.to_json_obj())
        my_dict['errors'] = my_encoded_errors

        return my_dict


class CheckError(IkatsException):
    """
    This subclass of IkatsException is wrapping the object CheckStatus set by constructor:
    useful to raise an exception keeping the original status.

    """

    def __init__(self, msg, status):
        super(CheckError, self).__init__(msg)

        if not isinstance(status, CheckStatus):
            raise Exception("Expects status as CheckStatus instance")

        self._status = status
        self._msg = msg

    @property
    def status(self):
        """
        Gets the CheckStatus defined by constructor
        """
        return self._status

    @status.setter
    def status(self, value):
        """
        Sets the status
        """
        self._status = value

    @property
    def msg(self):
        """
        Gets the message of this CheckError
        """
        return self._msg

    @msg.setter
    def msg(self, value):
        """
        Sets the msg
        """
        self._msg = value


class CheckEngine(object):
    """
    The Checkengine is computing the checking rules applicable to types and values of argument/parameters
    of an Implementation.

    - It is involved during the building of a CustomizedAlgo as good values must be assigned to parameters.

    - It is involved during the execution of an Implementation or CustomizedAlgo as arguments/parameters are
    submitted to type and value checking before running the algorithm.
    """

    _checking_rules = FactoryCatalogue().get_checking_rules_per_types()

    @classmethod
    def get_checking_rules(cls):
        """
        Get the value-checking rules: the default configuration is FactoryCatalogue().get_checking_rules_per_types().

        Note: you can use set_checking_rules() in order to change the default value.
        (for instance in the unit tests, ...)
        :param cls:
        :type cls:
        :return: dictionary whose keys are configured functional types; and values are python
                functions (including lambda)
        :rtype: dict with str keys and function values
        """
        return cls._checking_rules

    @classmethod
    def set_checking_rules(cls, new_rules):
        """
        Replaces the default configuration of value-checking rules: using new_rules argument
        :param cls:
        :type cls:
        :param new_rules: dictionary whose keys are configured functional types;
                and values are python functions (including lambda)
        :type new_rules: dict with str keys and function values
        """
        cls._checking_rules = new_rules

    def __init__(self, checked_resource, checked_value_context, check_status=None):
        if check_status is not None:
            self._check_status = check_status
        else:
            self._check_status = CheckStatus(checked_resource)

        self._checked_resource = checked_resource
        self._checked_value_context = checked_value_context

        # get the implementation
        if isinstance(checked_resource, CustomizedAlgo):
            self._implementation = checked_resource.implementation

        elif isinstance(checked_resource, Implementation):
            self._implementation = checked_resource

        else:
            msg = "Checkengine init failed: unsupported type={} for checked_resource."
            raise IkatsException(msg.format(type(checked_resource).__name__))

    def get_check_status(self):
        """
        Get the check status
        :return:
        """
        return self._check_status

    def has_errors(self):
        """
        Return True if there is errors, False otherwise
        :return:
        """
        return self.get_check_status().has_errors()

    def check_type(self, profile_item, checked_value):
        """
        Checks the type of the value according to
          - the provided ProfileItem definition,
          - and the CheckEngine.get_checking_rules()
        Returns the CheckStatus.
        :param profile_item: the checking configuration of parameter/argument
        :type profile_item: ProfileItem (superclass of Parameter and Argument)
        :param checked_value: the checked value
        :type checked_value: object
        :return: the checkStatus completed with this check
        :rtype: CheckStatus
        """
        try:
            my_checked_type = profile_item.data_format

            if my_checked_type is not None:
                my_eval = True
                if my_checked_type in CheckEngine.get_checking_rules():
                    my_func = CheckEngine.get_checking_rules()[my_checked_type]
                    my_eval = my_func(checked_value)

                if not my_eval:
                    target_info = "{} {}".format(type(profile_item).__name__, profile_item.name)
                    self._check_status.add_error(check_type="type",
                                                 check_target=target_info,
                                                 checked_value=checked_value,
                                                 msg="Bad value for type=" + my_checked_type)
        except Exception as err:

            LOGGER.warning("Failed to apply checking rule on value=%s with profile_item=%s", checked_value,
                           profile_item)
            LOGGER.exception(err)

        return self._check_status

    def check_domain(self, profile_item, checked_value):
        """
        Checks that the checked_value belongs to the domain_of_values, when configured.
        Returns the CheckStatus.
        :param profile_item: the catalogue configuration ProfileItem associated to the value
        :type profile_item: ProfileItem
        :param checked_value: the value
        :type checked_value: object
        :return: the checkStatus completed with this check
        :rtype: checkStatus
        """
        my_checked_domain = profile_item.domain_of_values
        if my_checked_domain is not None:

            try:
                my_domain_obj = json.loads(my_checked_domain)
                if type(my_domain_obj) is list:
                    if type(checked_value) is list:
                        my_eval = True
                        for value in checked_value:
                            my_eval = my_eval and (value in my_domain_obj)
                    else:
                        my_eval = (checked_value in my_domain_obj)
                else:
                    # try to execute a function check_<function>( name, value)
                    # provided with the algo <function>
                    my_eval = True

                if not my_eval:
                    self._check_status.add_error(check_type="domain",
                                                 check_target=profile_item,
                                                 checked_value=checked_value,
                                                 msg="not in the domain specified by: " + my_checked_domain)
            except Exception as err:

                LOGGER.warning("Failed to apply domain_of_values checking rule on value=%s with domain_of_values=%s",
                               checked_value, my_checked_domain)
                LOGGER.exception(err)

        return self._check_status

    def check_customized_values(self):
        """
        Checks the Customized algo: self._checked_resource
         * check each defined type, according to CheckEngine.get_checking_rules()
          * see check_type()
         * check each defined domain
          * see check_domain()
        :return: the checkStatus completed with these checks
        :rtype: checkStatus
        """
        if not isinstance(self._checked_resource, CustomizedAlgo):
            raise IkatsException(
                "CheckEngine::check_customized_values() requires self._checked_resource as CustomizedAlgo")

        for _, custom_param in self._checked_resource.custom_params.items():
            the_profile_item = custom_param.get_parameter()
            value = custom_param.get_value()
            if value is not None:
                self.check_type(profile_item=the_profile_item, checked_value=value)
                self.check_domain(profile_item=the_profile_item, checked_value=value)

        return self._check_status
